package auth

import (
	"bytes"
	"crypto"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base32"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/mitchellh/mapstructure"

	"zotregistry.dev/zot/v2/pkg/api"
)

type (
	AccessTokenResponse struct {
		AccessToken string `json:"access_token"` //nolint:tagliatelle // token format
	}

	AuthHeader struct {
		Realm   string
		Service string
		Scope   string
	}
)

func MakeAuthTestServer(serverKey, signAlg string, unauthorizedNamespace string) *httptest.Server {
	signingKey := loadPrivateKeyFromFile(serverKey)
	signingMethod := jwt.GetSigningMethod(signAlg)

	authTestServer := httptest.NewServer(http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {
		if request.Method != http.MethodGet {
			response.WriteHeader(http.StatusMethodNotAllowed)

			return
		}

		var access []api.ResourceAccess

		scope := request.URL.Query().Get("scope")
		if scope != "" {
			parts := strings.Split(scope, ":")
			name := parts[1]
			actions := strings.Split(parts[2], ",")

			if name == unauthorizedNamespace {
				actions = []string{}
			}

			access = []api.ResourceAccess{
				{
					Name:    name,
					Type:    "repository",
					Actions: actions,
				},
			}
		}

		now := time.Now()
		claims := api.ClaimsWithAccess{
			Access: access,
			RegisteredClaims: jwt.RegisteredClaims{
				ExpiresAt: jwt.NewNumericDate(now.Add(time.Minute * 1)),
				IssuedAt:  jwt.NewNumericDate(now),
				Issuer:    "Zot",
				Audience:  []string{"Zot Registry"},
			},
		}

		token := jwt.NewWithClaims(signingMethod, claims)

		signedString, err := token.SignedString(signingKey)
		if err != nil {
			panic(err)
		}

		response.Header().Set("Content-Type", "application/json")
		fmt.Fprintf(response, `{"access_token": "%s"}`, signedString)
	}))

	return authTestServer
}

// legacyAccessEntry represents the access claim format used by older versions of zot
// (via chartmuseum/auth). This maintains backward compatibility for token validation.
type legacyAccessEntry struct {
	Type    string   `json:"type"`
	Name    string   `json:"name"`
	Actions []string `json:"actions"`
}

// legacyClaims represents the JWT claims format used by older versions of zot (via chartmuseum/auth).
// Key differences from the new format:
// - Uses numeric Unix timestamps for iat/exp instead of jwt.NumericDate.
// - Includes aud and iss at the top level of claims (not nested in RegisteredClaims).
// - This format is compatible with tokens generated by chartmuseum/auth v0.5.0.
type legacyClaims struct {
	Access    []legacyAccessEntry `json:"access"`
	Audience  string              `json:"aud,omitempty"`
	Issuer    string              `json:"iss,omitempty"`
	IssuedAt  int64               `json:"iat,omitempty"`
	ExpiresAt int64               `json:"exp,omitempty"`
}

// GetAudience implements jwt.Claims interface.
func (c legacyClaims) GetAudience() (jwt.ClaimStrings, error) {
	if c.Audience == "" {
		return nil, nil //nolint:nilnil // required by jwt.Claims interface
	}

	return jwt.ClaimStrings{c.Audience}, nil
}

// GetExpirationTime implements jwt.Claims interface.
func (c legacyClaims) GetExpirationTime() (*jwt.NumericDate, error) {
	if c.ExpiresAt == 0 {
		return nil, nil //nolint:nilnil // required by jwt.Claims interface
	}

	return jwt.NewNumericDate(time.Unix(c.ExpiresAt, 0)), nil
}

// GetIssuedAt implements jwt.Claims interface.
func (c legacyClaims) GetIssuedAt() (*jwt.NumericDate, error) {
	if c.IssuedAt == 0 {
		return nil, nil //nolint:nilnil // required by jwt.Claims interface
	}

	return jwt.NewNumericDate(time.Unix(c.IssuedAt, 0)), nil
}

// GetIssuer implements jwt.Claims interface.
func (c legacyClaims) GetIssuer() (string, error) {
	return c.Issuer, nil
}

// GetNotBefore implements jwt.Claims interface.
func (c legacyClaims) GetNotBefore() (*jwt.NumericDate, error) {
	return nil, nil //nolint:nilnil // required by jwt.Claims interface
}

// GetSubject implements jwt.Claims interface.
func (c legacyClaims) GetSubject() (string, error) {
	return "", nil
}

// generateKIDFromPublicKey generates a key ID (kid) from an RSA public key.
// This replicates the algorithm used by docker/libtrust and chartmuseum/auth
// to ensure backward compatibility with tokens generated by older versions of zot.
func generateKIDFromPublicKey(pubKey *rsa.PublicKey) (string, error) {
	derBytes, err := x509.MarshalPKIXPublicKey(pubKey)
	if err != nil {
		return "", err
	}

	hasher := sha256.New()
	hasher.Write(derBytes)

	return keyIDEncode(hasher.Sum(nil)[:30]), nil
}

// keyIDEncode encodes a byte slice into a colon-separated base32 string.
// This is the format used by docker/libtrust for key IDs.
func keyIDEncode(b []byte) string {
	encoded := strings.TrimRight(base32.StdEncoding.EncodeToString(b), "=")

	var buf bytes.Buffer

	var idx int
	for idx = 0; idx < len(encoded)/4-1; idx++ {
		start := idx * 4
		end := start + 4
		buf.WriteString(encoded[start:end] + ":")
	}

	buf.WriteString(encoded[idx*4:])

	return buf.String()
}

// MakeAuthTestServerLegacy makes a test HTTP server to generate bearer tokens using the legacy
// token format that was previously generated by github.com/chartmuseum/auth. This verifies
// backward compatibility of the token authentication process with older versions of zot.
//
// Key differences from MakeAuthTestServer:
// - Adds a 'kid' header computed from the public key (docker/libtrust format).
// - Uses legacy claims format with numeric timestamps.
// - Supports multiple scopes in a single request.
// - Only uses RS256 signing algorithm.
func MakeAuthTestServerLegacy(serverKey string, unauthorizedNamespace string) *httptest.Server {
	privateKey := loadRSAPrivateKeyFromFile(serverKey)

	kid, err := generateKIDFromPublicKey(&privateKey.PublicKey)
	if err != nil {
		panic(err)
	}

	authTestServer := httptest.NewServer(http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {
		if request.Method != http.MethodGet {
			response.WriteHeader(http.StatusMethodNotAllowed)

			return
		}

		var access []legacyAccessEntry

		scopes := request.URL.Query()["scope"]

		for _, scope := range scopes {
			if scope == "" {
				continue
			}

			parts := strings.Split(scope, ":")
			name := parts[1]
			actions := strings.Split(parts[2], ",")

			if name == unauthorizedNamespace {
				actions = []string{}
			}

			access = append(access, legacyAccessEntry{
				Name:    name,
				Type:    "repository",
				Actions: actions,
			})
		}

		now := time.Now()
		claims := legacyClaims{
			Access:    access,
			Audience:  "Zot Registry",
			Issuer:    "Zot",
			IssuedAt:  now.Unix(),
			ExpiresAt: now.Add(time.Minute * 1).Unix(),
		}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = kid

		signedString, err := token.SignedString(privateKey)
		if err != nil {
			panic(err)
		}

		response.Header().Set("Content-Type", "application/json")
		fmt.Fprintf(response, `{"access_token": "%s"}`, signedString)
	}))

	return authTestServer
}

func ParseBearerAuthHeader(authHeaderRaw string) *AuthHeader {
	re := regexp.MustCompile(`([a-zA-z]+)="(.+?)"`)
	matches := re.FindAllStringSubmatch(authHeaderRaw, -1)
	matchmap := make(map[string]string)

	for i := range matches {
		matchmap[matches[i][1]] = matches[i][2]
	}

	var h AuthHeader
	if err := mapstructure.Decode(matchmap, &h); err != nil {
		panic(err)
	}

	return &h
}

// loadRSAPrivateKeyFromFile loads an RSA private key from a PEM file.
// This is used by MakeAuthTestServerLegacy which only supports RSA keys.
func loadRSAPrivateKeyFromFile(path string) *rsa.PrivateKey {
	privateKeyBytes, err := os.ReadFile(path)
	if err != nil {
		panic(err)
	}

	rsaKey, err := jwt.ParseRSAPrivateKeyFromPEM(privateKeyBytes)
	if err != nil {
		panic("failed to parse RSA private key from file " + path + ": " + err.Error())
	}

	return rsaKey
}

func loadPrivateKeyFromFile(path string) crypto.PrivateKey {
	privateKeyBytes, err := os.ReadFile(path)
	if err != nil {
		panic(err)
	}

	rsaKey, err := jwt.ParseRSAPrivateKeyFromPEM(privateKeyBytes)
	if err == nil {
		return rsaKey
	}

	ecKey, err := jwt.ParseECPrivateKeyFromPEM(privateKeyBytes)
	if err == nil {
		return ecKey
	}

	edKey, err := jwt.ParseEdPrivateKeyFromPEM(privateKeyBytes)
	if err == nil {
		return edKey
	}

	panic("no valid private key found in file " + path)
}
